---
title: "Heapstore"
url: "docs/heapstore"
tags: []
author: "Jiří Mayer"
datePublished: null
dateUpdated: "2023-05-31"
---

## Introduction

Heapstore is a Unisave component that lets you access the database directly from the game client. It is the best choice for storage of data, when you don't need complicated database queries or backend logic. As it can be used together with [facets](facets) and [entities](entities), it's best to start using Unisave with Heapstore and then learn the other, lower-level approaches when needed.

```
[image of how the game client directly reads and writes
documents in the database over the internet, through heapstore]
```


## Database structure

The [ArangoDB](https://www.arangodb.com/) database used by Unisave organizes data into *collections* and *documents*.

A database document is a [JSON](https://www.json.org/json-en.html) object, storing data about some entity (e.g. a player). A document might look like this:

```json
{
    "_id": "players/567349",
    "_key": "567349",
    "_rev": "_fJRP0i---",
    "name": "John Doe",
    "score": 42,
    "isBanned": false,
    "registeredAt": "2023-05-31T08:21:40Z"
}
```

You can define your own fields (like `name`, `score`, `isBanned`, `createdAt`) and store your data in them. Each document might have different fields and you specify them when the document is created or updated.

Documents are organized into collections. Collection is a list of documents that somehow belong together. You can, for example, create a collection named `players` for all your registered players.

```
[image of the collection-document-data structure]
```

A document is identified by its `_key`. It has to be unique within the collection and can either be provided explicitly, or is auto-generated by the database during document creation. Since you typically want to also know the document's collection, it's best to use the `_id` field to identify a document. The `_id` field is simply the collection name and document key separated by a slash.


## Writing data

The following code can be used to insert new documents into a collection.

```cs
using System;
using UnityEngine;
using Unisave.Heapstore;

class MyController : MonoBehaviour
{
    public void LogEvent(string name)
    {
        this.Collection("events")
            .Add(new Dictionary<string, object> {
                ["name"] = name,
                ["time"] = DateTime.UtcNow
            });
    }
}
```

Notice the `using Unisave.Heapstore;` statement. It is needed for the `this.Collection(...)` method to be available.


### Handling the response

If you want to get the created document back and store it in a variable, you can define a `Then` callback to be called after the operation finishes.

```cs
using System;
using UnityEngine;
using Unisave.Heapstore;

class MyController : MonoBehaviour
{
    public void LogEvent(string name)
    {
        Debug.Log("Storing event...");

        this.Collection("events")
            .Add(new Dictionary<string, object> {
                ["name"] = name,
                ["time"] = DateTime.UtcNow
            })
            .Then(document => {
                Debug.Log(document);
            });
        
        Debug.Log("End of the function.");
    }
}
```

Don't forget that the operation takes some time (around 0.1 seconds). The `Then` callback only registers the code to be called after the operation finishes. This code is called long after the function finishes. The log from the code above would be:

```
[18:16:55] Storing event...
[18:16:55] End of the function.
(~0.1 second pause)
[18:16:56] {"name":"levelFinished","time":"2023-05-31T18:56:34.000Z"}
```


### Asynchronous programming

> **TODO:** Asnyc-await description should be moved to a separate documentation page

Using the `Then` callback might be ok for simple operations, but when you want to chain a series of operations, the code would get really messy:

```cs
void MyFunction()
{
    DoSomething()
        .Then(a => {
            DoSomething()
                .Then(b => {
                    DoSomething()
                        .Then(c => {
                            // oh, man!
                        });
                });
        });
}
```

What you really want is something like this:

```cs
void MyFunction()
{
    var a = DoSomething();
    var b = DoSomething();
    var c = DoSomething();
}
```

Luckily, C# has the keywords `async` and `await` that let you write asynchronous code almost like the regular synchronous code you are used to. You just need to mark `MyFunction` to be an `async` (asynchronous) function and then `await` all the inner operations:

```cs
async void MyFunction()
{
    var a = await DoSomething();
    var b = await DoSomething();
    var c = await DoSomething();
}
```

The C# compiler translates this to something very similar to the `Then` chain.

> **Note:** If you are familiar with Unity coroutines, then think of `async void` like `IEnumerable` and similarly of `await` like `yield return`. Unity executes asynchronous functions just like coroutines, except that they cooperate better with C#.

We can now rewrite our document inserting code to use `async-await`:

```cs
using System;
using UnityEngine;
using Unisave.Heapstore;

class MyController : MonoBehaviour
{
    // /!\ async /!\
    public async void LogEvent(string name)
    {
        Debug.Log("Storing event...");

        //              /!\ await /!\
        Document document = await this.Collection("events")
            .Add(new Dictionary<string, object> {
                ["name"] = name,
                ["time"] = DateTime.UtcNow
            });
        
        Debug.Log(document);
        
        Debug.Log("End of the function.");
    }
}
```

The log from the code above will be:

```
[18:16:55] Storing event...
(~0.1 second pause inside 'await')
[18:16:56] {"name":"levelFinished","time":"2023-05-31T18:56:34.000Z"}
[18:16:56] End of the function.
```

When using Heapstore, it is common that you want to make a series of operations, one after the other. Say, fetching a document, reading its content, then fetching some other document. For this reason will the rest of this documentation use only the `async-await` approach.


### Writing individual documents

You can create or overwrite a document:

```cs
Document document = await this
    .Collection("events")
    .Document("john")
    .Set(new Dictionary<string, object> {
        ["name"] = "John Doe",
        ["score"] = 42
    });
```

You can modify a document you have downloaded earlier:

```cs
this.Document(document.Id)
    .Set(new Dictionary<string, object> {
        ["name"] = "John Doe",
        ["score"] = 42
    });
```


## Reading individual documents

```cs
// by knowing the ID
Document document = await this
    .Collection("players")
    .Document("john")
    .Get();

// by knowing the ID directly
Document document = await this
    .Document("players/john")
    .Get();
```


## Quick API showcase


### Read a specific document

```cs
Document document = await this
    .Collection("players")
    .Document("john")
    .Get();

// alternatively
Document document = await this
    .Document("players/john")
    .Get();

Debug.Log(document.Collection); // "players"
Debug.Log(document.Key); // "john"
Debug.Log(document.Id); // "players/john"
Debug.Log(document.Data); // JsonObject, e.g. {"score":42}
```

Convert to a custom class instance:

```cs
class MyPlayer
{
    public int score;
}
```

```cs
MyPlayer player = document.As<MyPlayer>();
Debug.Log(player.score); // 42
```


### Insert a new document into collection

```cs
Document document = await this
    .Collection("myCollection")
    .Add(new Dictionary<string, object> {
        ["foo"] = "bar"
    });
```


### Set a document (create or overwrite)

```cs
Document writtenDoc = await this
    .Document("players/john")
    .Set(new Dictionary<string, object> {
        ["score"] = 42
    });
```


### Get all documents in a collection

```cs
List<Document> docs = await this
    .Collection("players")
    .Get();
```


### Filter documents

```cs
List<Document> docs = await this
    .Collection("players")
    .Filter("score", ">", 10)
    .Get();
```


### Get the first document of a query

```cs
Document doc = await this
    .Collection("players")
    .Filter("email", "==", email)
    .First();

// null if no such document
```


## API Reference


**`CollectionReference`**<br>
Identifies one collection of the database. Lets you access documents and perform queries.


### Documents

**`DocumentReference`**<br>
Identifies one document in the database (which may not exist though). The reference can be used to retrieve `DocumentSnapshot` instances and to create, update, or delete the document.

**`DocumentSnapshot`**<br>
Represents a document at a specific point in time. It contains extra metadata about changes if there was some previous snapshot. It is never `null`, missing document is represented by a special state. It is also implicitly castable to `Document`.

**`Document`**<br>
Similar to `DocumentSnapshot`, just missing the extra metadata. It is basically a glorified `JsonObject`. It's designed to be used in simpler usecases where temporal document differences are not needed to be watched. Also, here, non-existing document is represented by `null`.

It is primarily useful for queries that return at most one document. These queries can be executed by calling `.First()`, which cannot return an "empty" `DocumentSnapshot`, since a snapshot needs to know the document ID. But is not known for such a query.


### Queries

**`Query`**<br>
Identifies a list of documents in the database. It can be used to retrive them from the database as a `QuerySnapshot` instance. Analogous to `DocumentReference`, but for multiple documents.

**`QuerySnapshot`**<br>
Represents the value of a query at a specific point in time. It conains extra metadata about changes from a possible previous snapshot. It is never `null`. Analogous to `DocumentSnapshot`, but for multiple documents. Implicitly castable to `List<DocumentSnapshot>`.




















## Interacting with Heapstore `TODO`

Use this.something from mono behaviours. Async, await, etc.


## Working with a document

A document is fully identified by its ID. We can use IDs to read and write specific documents. We can either get to a document in two steps, specifying a collection and the key, or in one step, specifying only the ID:

```cs
using System;
using UnityEngine;
using Unisave.Heapstore;

class MyController : MonoBehaviour
{
    async void Start()
    {
        // specify collection and document key separately
        var result = await this
            .Collection("players")
            .Document("john")
            .DO_SOME_ACTION(); // Get, Set, Delete
        
        // or specify only the document ID
        var result = await this
            .Document("players/john")
            .DO_SOME_ACTION(); // Get, Set, Delete
        
        Debug.Log(result);
    }
}
```


### Get

To read a document, you use the `Get()` method:

```cs
Document document = await this
    .Document("players/john")
    .Get();
```

If the document does not exist, the method will return a `null`. If the document exists, the returned object can be used to retrieve the document contents.

You can get the document metadata:

```cs
Debug.Log(document.Id); // "players/john"
Debug.Log(document.Collection); // "players"
Debug.Log(document.Key); // "john"
```

> **Note:** If the collection does not exist, it is treated like if the document did not exist and `null` is returned.


### Converting document to custom type

Imagine this is what the database document looks like:

```json
{
    "_id": "players/john",
    "_key": "john",
    "_rev": "_fJRP0i---",
    "name": "John Doe",
    "score": 42,
    "isBanned": false,
    "registeredAt": "2023-05-31T08:21:40Z"
}
```

The fetched document contains information about a player. You can define a `Player` class and convert the document into that class instance.

```cs
using System;
using Unisave;

class Player
{
    [SerializeAs("_id")]
    public string id;

    public string name;
    public int score;
    public bool isBanned;
    public DateTime registeredAt;
}
```

To convert the document, use the `As<T>()` method:

```cs
Document document = await this
    .Document("players/john")
    .Get();

Player player = document.As<Player>();

Debug.Log(player.name); // "John Doe"
Debug.Log(player.id); // "players/john"
```

It is not necessary to specify the `id` field in the `Player` class, but it is useful if you want to later save the document, because for saving you need the document ID again.

The `[SerializeAs("...")]` attribute lets you name the C# class fields differently than the JSON object fields.


### Working with raw JSON data

You can also work directly with the returned `Document` object and read and modify it as raw JSON. You can use the `Data` property that returns the document contents as a `JsonObject`:

```cs
Document document = await this
    .Document("players/john")
    .Get();

// read
string playerName = document.Data["name"];
int playerScore = document.Data["score"];

// modify
document.Data["isBanned"] = true;
```

Unisave uses the [LightJson](https://github.com/MarcosLopezC/LightJson) library and the `JsonObject` allows data access and modification.

The `Data` object does not contain the metadata fields, like `_id`, it contains only the user data.


### Set

To write a document to the database you use the `Set(...)` method:

```cs
Document storedDocument = await this
    .Document("players/john")
    .Set(new JsonObject {
        ["name"] = "Johnny Doey",
        ["score"] = 100
    });
```

The `Set` method creates the document if it doesn't exist yet. Otherwise it replaces the existing document with the new content. This means that all other fields not specified in the `Set` method will be removed.

> **Note:** If the collection does not exist, it gets automatically created.

The method also returns the state of the document after the write operation finishes. This is useful if you need to get the new `_rev` (revision) value.

The `Set` method accepts any value that can be serialized to a JSON object. This means you can use your custom `Player` class as well:

```cs
Player john = new Player {
    name = "John Doe",
    score = 100
};

await this
    .Document("players/john")
    .Set(john);
```

Special database fields (`_id`, `_key`) that would be present in the `Set` method body will be ignored. The true ID used is the ID passed to the `Document` method:

```cs
await this
    .Document("players/john") // this one matters
    .Set(new JsonObject {
        ["_id"] = "players/peter", // ignored
        ["name"] = "John"
    });
```


### Update

The method `Update` is similar to `Set`, but it updates only the fields that are provided and leaves the others untouched.

```cs
Document updatedDocument = await this
    .Document("players/john")
    .Set(new JsonObject {
        ["name"] = "Johnny Doey"
        // score and other fields stay untouched
    });

Debug.Log(updatedDocument.Data["score"]); // 42
```

If the document does not exist, it will be created with the specified fields.


### Add

So far, we only created documents with fixed IDs. While this might be useful sometimes, in most cases you want to generate document IDs dynamically and then look up documents dynamically by other fields (e.g. looking up players by emails or logins). When a new player registers, you want to generate a new, random ID for them. We can let the database generate the ID for us.

The `Add` method lets you insert a new document into a collection.

```cs
Document peter = await this
    .Collection("players")
    .Add(new JsonObject {
        ["name"] = "Peter",
        ["score"] = 0
    });

Debug.Log(peter.Id); // "players/231687"
```


### Delete

You can also delete a document by its ID, using the `Delete` method:

```cs
bool wasDeleted = await this
    .Document("players/231687")
    .Delete();

Debug.Log(wasDeleted); // true
```

The method returns `true` if the document existed and was actually deleted. If the document didn't exist, then no action was performed and `false` is returned instead.


## Document queries

### Reading entire collection

### Filter

### Sort

### Limit


## Stuff to be figured out

- security rules
- collection creation & indexes
- connectivity outage exceptions
- offline mode
- query listening
- interop with entities (createdAt, updatedAt) and entities over any collection name
- define a Unisave `AsyncOperation` instead of `FacetCall`
- set/delete carefully that checks revisions and works only in online mode
