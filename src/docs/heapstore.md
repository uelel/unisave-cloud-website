---
title: "Heapstore"
url: "docs/heapstore"
image: NO_IMAGE
tags: []
author: "Jiří Mayer"
datePublished: null
dateUpdated: "2023-06-01"
---


## Introduction

Heapstore is a Unisave component that lets you access the database directly from the game client. It is the best choice for storage of data, when you don't need complicated database queries or backend logic. As it can be used together with [facets](facets) and [entities](entities), it's best to start using Unisave with Heapstore and then learn the other, lower-level approaches when needed.

```
[image of how the game client directly reads and writes
documents in the database over the internet, through heapstore]
```


## Database structure

The [ArangoDB](https://www.arangodb.com/) database used by Unisave organizes data into *collections* and *documents*.

A database document is a [JSON](https://www.json.org/json-en.html) object, storing data about some entity (e.g. a player). A document might look like this:

```json
{
    "_id": "players/567349",
    "_key": "567349",
    "_rev": "_fJRP0i---",
    "name": "John Doe",
    "score": 42,
    "isBanned": false,
    "registeredAt": "2023-05-31T08:21:40Z"
}
```

You can define your own fields (like `name`, `score`, `isBanned`, `createdAt`) and store your data in them. Each document might have different fields and you specify them when the document is created or updated.

Documents are organized into collections. Collection is a list of documents that somehow belong together. You can, for example, create a collection named `players` for all your registered players.

```
[image of the collection-document-data structure]
```

A document is identified by its `_key`. It has to be unique within the collection and can either be provided explicitly, or is auto-generated by the database during document creation. Since you typically want to also know the document's collection, it's best to use the `_id` field to identify a document. The `_id` field is simply the collection name and document key separated by a slash.


## Enabling Heapstore

Heapstore is by default disabled, since without any security rules, it allows unrestricted access to the database.

To enable Heapstore, open the Unisave window `Tools > Unisave > Unisave Window`, go to the `Backend Code` tab, and in the list of disabled backend folders enable `HeapstoreBackend`.

```
[screenshot of what needs to be clicked]
```

Alternatively you can navigate to the backend folder definition file and set uploading to `always`:

```
Assets/Plugins/Unisave/Heapstore/Backend/HeapstoreBackend.asset
```

> **Warning:** Make sure you specify proper security rules before you release your game. Without security rules, any client can modify and read all documents in the database.


## Interacting with Heapstore

Heapstore was designed to be used from inside `MonoBehaviour` scripts.

The following code can be used to insert new documents into a collection:

```cs
using System;
using UnityEngine;
using Unisave.Heapstore;
using LightJson;

class MyEventLogger : MonoBehaviour
{
    public void LogEvent(string name)
    {
        this.Collection("events")
            .Add(new JsonObject {
                ["name"] = name,
                ["time"] = DateTime.UtcNow
            });
    }
}
```

Notice the `using Unisave.Heapstore;` statement. It is needed for the `this.Collection(...)` method to be available.


### Handling the response

If you want to get the created document back and store it in a variable, you can define a `Then` callback to be called after the operation finishes.

```cs
using System;
using UnityEngine;
using Unisave.Heapstore;
using LightJson;

class MyEventLogger : MonoBehaviour
{
    public void LogEvent(string name)
    {
        Debug.Log("Storing event...");

        this.Collection("events")
            .Add(new JsonObject {
                ["name"] = name,
                ["time"] = DateTime.UtcNow
            })
            .Then(document => {
                Debug.Log(document);
            });
        
        Debug.Log("End of the function.");
    }
}
```

Don't forget that the operation takes some time (around 0.1 seconds). The `Then` callback only registers the code to be called after the operation finishes. This code is called long after the function finishes. The log from the code above would be:

```
[18:16:55] Storing event...
[18:16:55] End of the function.
(~0.1 second pause)
[18:16:56] {"name":"levelFinished","time":"2023-05-31T18:56:34.000Z"}
```


### Asynchronous programming

> **TODO:** Asnyc-await description should be moved to a separate documentation page. Link it from here and here keep only the very basics.

Using the `Then` callback might be ok for simple operations, but when you want to chain a series of operations, the code would get really messy:

```cs
void MyFunction()
{
    DoSomething()
        .Then(a => {
            DoSomething()
                .Then(b => {
                    DoSomething()
                        .Then(c => {
                            // oh, man!
                        });
                });
        });
}
```

What you really want is something like this:

```cs
void MyFunction()
{
    var a = DoSomething();
    var b = DoSomething();
    var c = DoSomething();
}
```

Luckily, C# has the keywords `async` and `await` that let you write asynchronous code almost like the regular synchronous code you are used to. You just need to mark `MyFunction` to be an `async` (asynchronous) function and then `await` all the inner operations:

```cs
async void MyFunction()
{
    var a = await DoSomething();
    var b = await DoSomething();
    var c = await DoSomething();
}
```

The C# compiler translates this to something very similar to the `Then` chain.

> **Note:** If you are familiar with Unity coroutines, then think of `async void` like `IEnumerable` and similarly of `await` like `yield return`. Unity executes asynchronous functions just like coroutines, except that they cooperate better with C#.

We can now rewrite our document inserting code to use `async-await`:

```cs
using System;
using UnityEngine;
using Unisave.Heapstore;
using LightJson;

class MyEventLogger : MonoBehaviour
{
    // /!\ async /!\
    public async void LogEvent(string name)
    {
        Debug.Log("Storing event...");

        //              /!\ await /!\
        Document document = await this
            .Collection("events")
            .Add(new JsonObject {
                ["name"] = name,
                ["time"] = DateTime.UtcNow
            });
        
        Debug.Log(document);
        
        Debug.Log("End of the function.");
    }
}
```

The log from the code above will be:

```
[18:16:55] Storing event...
(~0.1 second pause inside 'await')
[18:16:56] {"name":"levelFinished","time":"2023-05-31T18:56:34.000Z"}
[18:16:56] End of the function.
```

When using Heapstore, it is common that you want to make a series of operations, one after the other. Say, fetching a document, reading its content, then fetching some other document. For this reason will the rest of this documentation use only the `async-await` approach.


## Working with a document

A document is fully identified by its ID. We can use IDs to read and write specific documents. We can either get to a document in two steps, specifying a collection and the key, or in one step, specifying only the ID:

```cs
using System;
using UnityEngine;
using Unisave.Heapstore;

class MyController : MonoBehaviour
{
    async void Start()
    {
        // specify collection and document key separately
        var result = await this
            .Collection("players")
            .Document("john")
            .DO_SOME_ACTION(); // Get, Set, Delete
        
        // or specify only the document ID
        var result = await this
            .Document("players/john")
            .DO_SOME_ACTION(); // Get, Set, Delete
        
        Debug.Log(result);
    }
}
```


### Get

To read a document, you use the `Get()` method:

```cs
Document document = await this
    .Document("players/john")
    .Get();
```

If the document does not exist, the method will return a `null`. If the document exists, the returned object can be used to retrieve the document contents.

You can get the document metadata:

```cs
Debug.Log(document.Id); // "players/john"
Debug.Log(document.Collection); // "players"
Debug.Log(document.Key); // "john"
```

> **Note:** If the collection does not exist, it is treated like if the document did not exist and `null` is returned.


### Converting document to custom type

Imagine this is what the database document looks like:

```json
{
    "_id": "players/john",
    "_key": "john",
    "_rev": "_fJRP0i---",
    "name": "John Doe",
    "score": 42,
    "isBanned": false,
    "registeredAt": "2023-05-31T08:21:40Z"
}
```

The fetched document contains information about a player. You can define a `Player` class and convert the document into that class instance.

```cs
using System;
using Unisave;

class Player
{
    [SerializeAs("_id")]
    public string id;

    public string name;
    public int score;
    public bool isBanned;
    public DateTime registeredAt;
}
```

To convert the document, use the `As<T>()` method:

```cs
Document document = await this
    .Document("players/john")
    .Get();

Player player = document.As<Player>();

Debug.Log(player.name); // "John Doe"
Debug.Log(player.id); // "players/john"
```

It is not necessary to specify the `id` field in the `Player` class, but it is useful if you want to later save the document, because for saving you need the document ID again.

The `[SerializeAs("...")]` attribute lets you name the C# class fields differently than the JSON object fields.

You can shorten the code above if you don't need the `Document` but only need the `Player` by using `GetAs<T>()`:

```cs
Player player = await this
    .Document("players/john")
    .GetAs<Player>();
```


### Working with raw JSON data

You can also work directly with the returned `Document` object and read and modify it as raw JSON. You can use the `Data` property that returns the document contents as a `JsonObject`:

```cs
Document document = await this
    .Document("players/john")
    .Get();

// read
string playerName = document.Data["name"];
int playerScore = document.Data["score"];

// modify
document.Data["isBanned"] = true;
```

Unisave uses the [LightJson](https://github.com/MarcosLopezC/LightJson) library and the `JsonObject` allows data access and modification.

The `Data` object does not contain the metadata fields, like `_id`, it contains only the user data.


### Set

To write a document to the database you use the `Set(...)` method:

```cs
Document storedDocument = await this
    .Document("players/john")
    .Set(new JsonObject {
        ["name"] = "Johnny Doey",
        ["score"] = 100
    });
```

The `Set` method creates the document if it doesn't exist yet. Otherwise it replaces the existing document with the new content. This means that all other fields not specified in the `Set` method will be removed.

> **Note:** If the collection does not exist, it gets automatically created.

The method also returns the state of the document after the write operation finishes. This is useful if you need to get the new `_rev` (revision) value.

The `Set` method accepts any value that can be serialized to a JSON object. This means you can use your custom `Player` class as well:

```cs
Player john = new Player {
    name = "John Doe",
    score = 100
};

await this
    .Document("players/john")
    .Set(john);
```

Special database fields (`_id`, `_key`) that would be present in the `Set` method body will be ignored. The true ID used is the ID passed to the `Document` method:

```cs
await this
    .Document("players/john") // this one matters
    .Set(new JsonObject {
        ["_id"] = "players/peter", // ignored
        ["name"] = "John"
    });
```


### Update

The method `Update` is similar to `Set`, but it updates only the fields that are provided and leaves the others untouched.

```cs
Document updatedDocument = await this
    .Document("players/john")
    .Set(new JsonObject {
        ["name"] = "Johnny Doey"
        // score and other fields stay untouched
    });

Debug.Log(updatedDocument.Data["score"]); // 42
```

If the document does not exist, it will be created with the specified fields.


### Add

So far, we've only created documents with fixed IDs. While this might be useful sometimes, in most cases you want to generate document IDs dynamically and then look up documents dynamically by other fields (e.g. looking up players by emails or logins). When a new player registers, you want to generate a new, random ID for them. We can let the database generate the ID for us.

The `Add` method lets you insert a new document into a collection.

```cs
Document peter = await this
    .Collection("players")
    .Add(new JsonObject {
        ["name"] = "Peter",
        ["score"] = 0
    });

Debug.Log(peter.Id); // "players/231687"
```


### Delete

You can also delete a document by its ID, using the `Delete` method:

```cs
bool wasDeleted = await this
    .Document("players/231687")
    .Delete();

Debug.Log(wasDeleted); // true
```

The method returns `true` if the document existed and was actually deleted. If the document didn't exist, then no action was performed and `false` is returned instead.


## Document queries

Queries let you specify a subset of documents in a collection and then fetch all of them at once.


### Reading entire collection

The simplest query fetches all the documents in a collection:

```cs
List<Document> documents = await this
    .Collection("players")
    .Get();
```

The query returns a list of `Document` instances.

> **Note:** The shown query is only for demonstration purposes. If there are lots of players, the query would only return the first 1000 of them. If you actually want to go through more than 1000 documents with a query, check out *chunking*, described below.


### Filter

Typically, when you run queries, you want only some of the documents in a collection. This can be achieved by filtering the documents. For example, we can query in-game items that belong to some player:

```cs
string somePlayerId = "players/943579";

List<Document> documents = await this
    .Collection("items")
    .Filter("owner", "==", somePlayerId)
    .Get();
```

This query matches documents, that have the `owner` field equal to `players/943579`.

You can also add a middle argument to specify what comparison to perform:

```cs
.Filter("field", "==", value)
.Filter("field", "!=", value)
.Filter("field", ">", value)
.Filter("field", ">=", value)
.Filter("field", "<", value)
.Filter("field", "<=", value)
.Filter("field", "IN", arrayOfValues)
.Filter("field", "NOT IN", arrayOfValues)
```

A query can have multiple filters simultaneously. Only documents that pass all the filters will be returned:

```cs
List<Document> mediumPricedItems = await this
    .Collection("items")
    .Filter("price", ">=", 12)
    .Filter("price", "<=", 30)
    .Get();
```


### Getting the first document

Sometimes your query returns at most one document. Say you want to get the player by their nickname. In such cases you can terminate the query with `First()` instead of `Get()`:

```cs
string interestingNick = "John";

Document player = await this
    .Collection("players")
    .Filter("nickname", interestingNick)
    .First();
```

If the query matches no documents, it returns `null`. If it matches more than one document, then it returns the first one.


### Converting query results to custom type

Let's say you have an `Item` class:

```cs
using System;
using Unisave;

class Item
{
    [SerializeAs("_id")]
    public string id;

    public string title;
    public int price;
    public float power;
}
```

You can ask the query to convert the results to your type by using `GetAs<T>()` or `FirstAs<T>()`:

```cs
List<Item> mediumPricedItems = await this
    .Collection("items")
    .Filter("price", ">=", 12)
    .Filter("price", "<=", 30)
    .GetAs<Item>();

Item firstItem = await this
    .Collection("items")
    .FirstAs<Item>();
```


### Sort

You can order the query result by a field:

```cs
List<Document> cheapestItems = await this
    .Collection("items")
    .Sort("price", "DESC")
    .Get();
```

The results can be sorted in the descending `DESC` or ascending `ASC` order.

By providing a list of tuples, you can sort by multiple fields simultaneously (i.e. when the first one equals, the second is used, and so on):

```cs
List<Document> cheapestItems = await this
    .Collection("items")
    .Sort(("price", "DESC"), ("name", "ASC"), ("_id", "ASC"))
    .Get();
```


### Limit

The `Limit(...)` method can be used to limit the number of results returned by a query. It can be used to implement a leaderboard:

```cs
List<Document> topScores = await this
    .Collection("leaderboard")
    .Sort("score", "DESC")
    .Limit(10) // take only top 10
    .Get();
```

You can also use limit with two arguments `Limit(skip, take)` to display the next pages of the leaderboard (skip the first 50 documents and take the next 10 documents):

```cs
List<Document> topScores = await this
    .Collection("leaderboard")
    .Sort("score", "DESC")
    .Limit(50, 10) // skip 50, take 10
    .Get();
```

It's better to be explicit, when C# allows it and the code is more readable:

```cs
.Limit(skip: 50, take: 10)
```


### Large responses and chunking `TODO`

TODO: design some API that will return `AsyncEnumerable<T>`, allow changing chunk size and do the paging by "last document ID", so that collection modifications do no re-iterate some elements (simple `Limit` would be vulnerable).


## Limitations

- Query
    - a single query can return no more then 1000 documents
    - one query works with one collection only, joins are not supported
- Filter
    - filter clauses can only be in conjunction (you cannot say `A or B`, only `A and B`)
        - you can do multiple queries and join the results at the client
    - there can be at most 20 of filter clauses in a query
    - for `IN` and `NOT IN`, the array can have at most 20 items
- Sort
    - sort at most by 20 fields


## Stuff to be figured out

- security rules
    - allow for field filtering (e.g. you can see other players, but only partially)
- collection creation & indexes
- connectivity outage exceptions
- offline mode
- query listening
- interop with entities (createdAt, updatedAt) and entities over any collection name
- set/delete carefully that checks revisions and works only in online mode
- serialization of anonymous types `new { foo = 42 }`


## API Reference


**`CollectionReference`**<br>
Identifies one collection of the database. Lets you access documents and perform queries.


### Documents

**`DocumentReference`**<br>
Identifies one document in the database (which may not exist though). The reference can be used to retrieve `DocumentSnapshot` instances and to create, update, or delete the document.

**`DocumentSnapshot`**<br>
Represents a document at a specific point in time. It contains extra metadata about changes if there was some previous snapshot. It is never `null`, missing document is represented by a special state. It is also implicitly castable to `Document`.

**`Document`**<br>
Similar to `DocumentSnapshot`, just missing the extra metadata. It is basically a glorified `JsonObject`. It's designed to be used in simpler usecases where temporal document differences are not needed to be watched. Also, here, non-existing document is represented by `null`.

It is primarily useful for queries that return at most one document. These queries can be executed by calling `.First()`, which cannot return an "empty" `DocumentSnapshot`, since a snapshot needs to know the document ID. But is not known for such a query.


### Queries

**`Query`**<br>
Identifies a list of documents in the database. It can be used to retrive them from the database as a `QuerySnapshot` instance. Analogous to `DocumentReference`, but for multiple documents.

**`QuerySnapshot`**<br>
Represents the value of a query at a specific point in time. It conains extra metadata about changes from a possible previous snapshot. It is never `null`. Analogous to `DocumentSnapshot`, but for multiple documents. Implicitly castable to `List<DocumentSnapshot>`.


## Exception Codes

Any Heapstore operation might throw a `Unisave.Heapstore.Backend.HeapstoreException`. This exception has the `ErrorNumber` integer value, that identifies what has gone wrong:


### General errors

**0 - ERROR_NO_ERROR**<br>
No error has occured.

**1 - ERROR_FAILED**<br>
Will be raised when a general error occured.

**2 - ERROR_INTERNAL**<br>
Will be raised when an internal error occured.

**3 - ERROR_FORBIDDEN**<br>
Will be raised when you are missing permissions for the operation.

**4 - ERROR_DISABLED**<br>
Will be raised when the Heapstore system is disabled. Typically raised when you forget to enable uploading of the Heapstore backend folder.

**5 - ERROR_CANNOT_CONNECT**<br>
Will be raised when the server cannot be reached.

**6 - ERROR_NOT_IMPLEMENTED**<br>
Will be raised when the requested operation is not implemented.


### Document API errors

**1000 - ERROR_DOCUMENT_MISSING**<br>
Will be raised when working with a document that does not exist (operations Get, Set, Update) and throwing is enabled. It is thrown either when the document does not exist, or the collection does not exist.

**1001 - ERROR_COLLECTION_MISSING**<br>
Will be raised when adding a document into a collection that does not exist (operation Add) and throwing is enabled.


### Query API errors

**2000 - ERROR_QUERY_FILTER_INVALID_OPERATOR**<br>
Will be raised if the used filter clause contains unknown comparison operator.

**2001 - ERROR_QUERY_FILTER_TOO_MANY_CLAUSES**<br>
Will be raised if there are too many filter clauses.

**2002 - ERROR_QUERY_FILTER_IN_ARRAY_TOO_LARGE**<br>
Will be raised if the `IN` and `NOT IN` operator arguments contain too many options.

**2003 - ERROR_QUERY_SORT_INVALID_DIRECTION**<br>
Will be raised if the sort direction value is invalid.

**2004 - ERROR_QUERY_SORT_TOO_MANY_FIELDS**<br>
Will be raised if the sort clause contains too many fields to sort by.


### Security rules errors

**3000 - ERROR_RULE_...**
