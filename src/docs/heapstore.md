---
title: "Heapstore"
url: "docs/heapstore"
tags: []
author: "Jiří Mayer"
datePublished: null
dateUpdated: "2023-05-31"
---

## Introduction

Heapstore is a Unisave component that lets you access the database directly from the game client. It is the best choice for storage of data, when you don't need complicated database queries or backend logic. As it can be used together with [facets](facets) and [entities](entities), it's best to start using Unisave with Heapstore and then learn the other, lower-level approaches when needed.

```
[image of how the game client directly reads and writes
documents in the database over the internet, through heapstore]
```


## Database structure

The [ArangoDB](https://www.arangodb.com/) database used by Unisave organizes data into *collections* and *documents*.

A database document is a [JSON](https://www.json.org/json-en.html) object, storing data about some entity (e.g. a player). A document might look like this:

```json
{
  "_id": "players/567349",
  "_key": "567349",
  "_rev": "_fJRP0i---",
  "name": "John Doe",
  "score": 42,
  "isBanned": false,
  "createdAt": "2023-05-31T08:21:40Z"
}
```

You can define your own fields (like `name`, `score`, `isBanned`, `createdAt`) and store your data in them. Each document might have different fields and you specify them when the document is created or updated.

Documents are organized into collections. Collection is a list of documents that somehow belong together. You can, for example, create a collection named `players` for all your registered players.

```
[image of the collection-document-data structure]
```

A document is identified by its `_key`. It has to be unique within the collection and can either be provided explicitly, or is auto-generated by the database during document creation. Since you typically want to also know the document's collection, it's best to use the `_id` field to identify a document. The `_id` field is simply the collection name and document key separated by a slash.


## Writing data

The following code can be used to insert new documents into a collection.

```cs
using System;
using UnityEngine;
using Unisave.Heapstore;

class MyController : MonoBehaviour
{
    public void LogEvent(string name)
    {
        this.Collection("events")
            .Add(new Dictionary<string, object> {
                ["name"] = name,
                ["time"] = DateTime.UtcNow
            });
    }
}
```

Notice the `using Unisave.Heapstore;` statement. It is needed for the `this.Collection(...)` method to be available.


### Handling the response

If you want to get the created document back and store it in a variable, you can define a `Then` callback to be called after the operation finishes.

```cs
using System;
using UnityEngine;
using Unisave.Heapstore;

class MyController : MonoBehaviour
{
    public void LogEvent(string name)
    {
        Debug.Log("Storing event...");

        this.Collection("events")
            .Add(new Dictionary<string, object> {
                ["name"] = name,
                ["time"] = DateTime.UtcNow
            })
            .Then(document => {
                Debug.Log(document);
            });
        
        Debug.Log("End of the function.");
    }
}
```

Don't forget that the operation takes some time (around 0.1 seconds). The `Then` callback only registers the code to be called after the operation finishes. This code is called long after the function finishes. The log from the code above would be:

```
[18:16:55] Storing event...
[18:16:55] End of the function.
(~0.1 second pause)
[18:16:56] {"name":"levelFinished","time":"2023-05-31T18:56:34.000Z"}
```


### Asynchronous programming

> **TODO:** Asnyc-await description should be moved to a separate documentation page

Using the `Then` callback might be ok for simple operations, but when you want to chain a series of operations, the code would get really messy:

```cs
void MyFunction()
{
    DoSomething()
        .Then(a => {
            DoSomething()
                .Then(b => {
                    DoSomething()
                        .Then(c => {
                            // oh, man!
                        });
                });
        });
}
```

What you really want is something like this:

```cs
void MyFunction()
{
    var a = DoSomething();
    var b = DoSomething();
    var c = DoSomething();
}
```

Luckily, C# has the keywords `async` and `await` that let you write asynchronous code almost like the regular synchronous code you are used to. You just need to mark `MyFunction` to be an `async` (asynchronous) function and then `await` all the inner operations:

```cs
async void MyFunction()
{
    var a = await DoSomething();
    var b = await DoSomething();
    var c = await DoSomething();
}
```

The C# compiler translates this to something very similar to the `Then` chain.

> **Note:** If you are familiar with Unity coroutines, then think of `async void` like `IEnumerable` and similarly of `await` like `yield return`. Unity executes asynchronous functions just like coroutines, except that they cooperate better with C#.

We can now rewrite our document inserting code to use `async-await`:

```cs
using System;
using UnityEngine;
using Unisave.Heapstore;

class MyController : MonoBehaviour
{
    // /!\ async /!\
    public async void LogEvent(string name)
    {
        Debug.Log("Storing event...");

        //              /!\ await /!\
        Document document = await this.Collection("events")
            .Add(new Dictionary<string, object> {
                ["name"] = name,
                ["time"] = DateTime.UtcNow
            });
        
        Debug.Log(document);
        
        Debug.Log("End of the function.");
    }
}
```

The log from the code above will be:

```
[18:16:55] Storing event...
(~0.1 second pause inside 'await')
[18:16:56] {"name":"levelFinished","time":"2023-05-31T18:56:34.000Z"}
[18:16:56] End of the function.
```

When using Heapstore, it is common that you want to make a series of operations, one after the other. Say, fetching a document, reading its content, then fetching some other document. For this reason will the rest of this documentation use only the `async-await` approach.


### Writing individual documents

You can create or overwrite a document:

```cs
Document document = await this
    .Collection("events")
    .Document("john")
    .Set(new Dictionary<string, object> {
        ["name"] = "John Doe",
        ["score"] = 42
    });
```

You can modify a document you have downloaded earlier:

```cs
this.Document(document.Id)
    .Set(new Dictionary<string, object> {
        ["name"] = "John Doe",
        ["score"] = 42
    });
```


## Reading individual documents

```cs
// by knowing the ID
Document document = await this
    .Collection("players")
    .Document("john")
    .Get();

// by knowing the ID directly
Document document = await this
    .Document("players/john")
    .Get();
```


## Quick API showcase


### Read a specific document

```cs
Document document = await this
    .Collection("players")
    .Document("john")
    .Get();

// alternatively
Document document = await this
    .Document("players/john")
    .Get();

Debug.Log(document.Collection); // "players"
Debug.Log(document.Key); // "john"
Debug.Log(document.Id); // "players/john"
Debug.Log(document.Data); // JsonObject, e.g. {"score":42}
```

Convert to a custom class instance:

```cs
class MyPlayer
{
    public int score;
}
```

```cs
MyPlayer player = document.As<MyPlayer>();
Debug.Log(player.score); // 42
```


### Insert a new document into collection

```cs
Document document = await this
    .Collection("myCollection")
    .Add(new Dictionary<string, object> {
        ["foo"] = "bar"
    });
```


### Set a document (create or overwrite)

```cs
Document writtenDoc = await this
    .Document("players/john")
    .Set(new Dictionary<string, object> {
        ["score"] = 42
    });
```


### Get all documents in a collection

```cs
List<Document> docs = await this
    .Collection("players")
    .Get();
```


### Filter documents

```cs
List<Document> docs = await this
    .Collection("players")
    .Filter("score", ">", 10)
    .Get();
```


### Get the first document of a query

```cs
Document doc = await this
    .Collection("players")
    .Filter("email", "==", email)
    .First();

// null if no such document
```


## API Reference


**`CollectionReference`**<br>
Identifies one collection of the database. Lets you access documents and perform queries.


### Documents

**`DocumentReference`**<br>
Identifies one document in the database (which may not exist though). The reference can be used to retrieve `DocumentSnapshot` instances and to create, update, or delete the document.

**`DocumentSnapshot`**<br>
Represents a document at a specific point in time. It contains extra metadata about changes if there was some previous snapshot. It is never `null`, missing document is represented by a special state. It is also implicitly castable to `Document`.

**`Document`**<br>
Similar to `DocumentSnapshot`, just missing the extra metadata. It is basically a glorified `JsonObject`. It's designed to be used in simpler usecases where temporal document differences are not needed to be watched. Also, here, non-existing document is represented by `null`.

It is primarily useful for queries that return at most one document. These queries can be executed by calling `.First()`, which cannot return an "empty" `DocumentSnapshot`, since a snapshot needs to know the document ID. But is not known for such a query.


### Queries

**`Query`**<br>
Identifies a list of documents in the database. It can be used to retrive them from the database as a `QuerySnapshot` instance. Analogous to `DocumentReference`, but for multiple documents.

**`QuerySnapshot`**<br>
Represents the value of a query at a specific point in time. It conains extra metadata about changes from a possible previous snapshot. It is never `null`. Analogous to `DocumentSnapshot`, but for multiple documents. Implicitly castable to `List<DocumentSnapshot>`.


